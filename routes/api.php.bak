<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "api" middleware group. Make something great!
|
*/

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});









Route::post("/generate-image", function (\Illuminate\Http\Request $request) {
    $request->validate([
        "path" => "required|"paths" => "required\|array",
        "paths\.*" => "required\|string",
        "language" => "required|"paths" => "required\|array",
        "paths\.*" => "required\|string",
        "features" => "nullable|"paths" => "required\|array",
        "paths\.*" => "required\|string",
    ]);

    $apiKey = env("GEMINI_API_KEY");
    if (!$apiKey) return response()->json(["ok"=>false,"message"=>"Missing GEMINI_API_KEY"], 500);

    $paths    = $request->input("paths"); // e.g. uploads/xxx.webp
    $language = $request->input("language");
    $features = trim((string)$request->input("features", ""));

    // 1) Read the uploaded image bytes from storage/app/public/...
    try {
        $bin = \Illuminate\Support\Facades\Storage::disk("public")->get($path);
    } catch (\Throwable $e) {
        return response()->json(["ok"=>false,"message"=>"Cannot read uploaded image","error"=>$e->getMessage()], 500);
    }

    // 2) Detect mime type (fallback by extension)
    $mime = null;
    try {
        $abs = \Illuminate\Support\Facades\Storage::disk("public")->path($path);
        $mime = @mime_content_type($abs) ?: null;
    } catch (\Throwable $e) {}

    if (!$mime) {
        $ext = strtolower(pathinfo($path, PATHINFO_EXTENSION));
        $mime = match ($ext) {
            "jpg", "jpeg" => "image/jpeg",
            "png" => "image/png",
            "webp" => "image/webp",
            default => "application/octet-stream",
        };
    }

    $b64img = base64_encode($bin);

    // 3) Build a tighter prompt that *forces* using the attached product image
    $promptText =
"Create ONE tall scrolling landing page mockup image (9:16), direct-response style.
Language: {$language}.
CRITICAL: Use the ATTACHED product image as the exact product shown throughout the page.
Do NOT invent a different product. Keep packaging/logo/colors consistent with the attached product.

Structure:
1) Hero (hook + promise + trust badges)
2) Before/After transformation
3) Authority + social proof + guarantee
4) Mechanism + ingredients grid + science visuals

Features to include if provided: {$features}.
High-converting, clean but energetic, product-centric, persuasive typography.";

    // 4) Call Gemini image model with BOTH text + inline product image
    $imageReq = [
        "contents" => [[
            "parts" => array_merge([["text" => $promptText]], $imageParts)
        ]],
        "generationConfig" => [
            "responseModalities" => ["IMAGE"]
        ]
    ];

    $ch = curl_init("https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent");
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_POST => true,
        CURLOPT_HTTPHEADER => ["Content-Type: application/json", "x-goog-api-key: {$apiKey}"],
        CURLOPT_POSTFIELDS => json_encode($imageReq),
        CURLOPT_TIMEOUT => 180,
    ]);
    $resp = curl_exec($ch);
    $http = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $err  = curl_error($ch);
    curl_close($ch);

    if ($resp === false) return response()->json(["ok"=>false,"message"=>"Image cURL error","error"=>$err], 500);

    $data = json_decode($resp, true);
    if ($http < 200 || $http >= 300) {
        return response()->json(["ok"=>false,"message"=>"Image model error","http"=>$http,"raw"=>$data], 500);
    }

    // 5) Extract returned inline image
    $parts = $data["candidates"][0]["content"]["parts"] ?? [];
    $b64 = null;
    foreach ($parts as $p) {
        if (isset($p["inlineData"]["data"])) { $b64 = $p["inlineData"]["data"]; break; }
    }
    if (!$b64) return response()->json(["ok"=>false,"message"=>"No inline image returned","raw"=>$data], 500);

    $outBin = base64_decode($b64);
    if ($outBin === false) return response()->json(["ok"=>false,"message"=>"base64 decode failed"], 500);

    $name = "outputs/lp_" . date("Ymd_His") . "_" . bin2hex(random_bytes(4)) . ".png";
    \Illuminate\Support\Facades\Storage::disk("public")->put($name, $outBin);

    return response()->json([
        "ok" => true,
        "output_url" => asset("storage/" . $name),
    ]);
});

Route::post("/upload", function (\Illuminate\Http\Request $request) {
    // Accept either "image" (single) or "images[]" (multiple)
    $files = [];

    if ($request->hasFile("images")) {
        $files = $request->file("images");
    } elseif ($request->hasFile("image")) {
        $files = [$request->file("image")];
    }

    if (!$files || count($files) === 0) {
        return response()->json(["ok"=>false,"message"=>"No images provided. Use image or images[]"], 422);
    }

    // Validate each file
    foreach ($files as $f) {
        if (!$f->isValid()) return response()->json(["ok"=>false,"message"=>"Invalid upload"], 422);
        $extOk = in_array(strtolower($f->getClientOriginalExtension()), ["jpg","jpeg","png","webp"]);
        if (!$extOk) return response()->json(["ok"=>false,"message"=>"Only jpg/jpeg/png/webp allowed"], 422);
        if ($f->getSize() > 8 * 1024 * 1024) return response()->json(["ok"=>false,"message"=>"Max 8MB per image"], 422);
    }

    $out = [];
    foreach ($files as $f) {
        $path = $f->store("uploads", "public");
        $out[] = [
            "path" => $path,
            "url"  => asset("storage/" . $path),
        ];
    }

    return response()->json([
        "ok" => true,
        "items" => $out
    ]);
});
