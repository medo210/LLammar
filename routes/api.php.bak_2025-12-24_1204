<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "api" middleware group. Make something great!
|
*/

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});











Route::post("/generate-image", function (\Illuminate\Http\Request $request) {
    $request->validate([
        "paths" => "required|array|min:1",
        "paths.*" => "required|string",
        "language" => "required|string",
        "features" => "nullable|string",
    ]);

    $apiKey = env("GEMINI_API_KEY");
    if (!$apiKey) return response()->json(["ok"=>false,"message"=>"Missing GEMINI_API_KEY"], 500);

    $paths    = $request->input("paths");
    $language = $request->input("language");
    $features = trim((string)$request->input("features", ""));

    // Build dialect instruction
    $dialect = "";
    if ($language === "Arabic (Egyptian Colloquial)") {
        $dialect = "Write ALL copy in Egyptian Arabic (عامية مصرية) طبيعي وبأسلوب بيع مقنع، من غير فصحى.";
    } elseif (stripos($language, "Arabic") !== false) {
        $dialect = "Write the copy in Modern Standard Arabic (فصحى) بأسلوب تسويقي مقنع.";
    }

    // 1) Read ALL uploaded images and attach them
    $imageParts = [];
    foreach ($paths as $p) {
        try {
            $bin = \Illuminate\Support\Facades\Storage::disk("public")->get($p);
        } catch (\Throwable $e) {
            return response()->json(["ok"=>false,"message"=>"Cannot read uploaded image","path"=>$p,"error"=>$e->getMessage()], 500);
        }

        $mime = null;
        try {
            $abs = \Illuminate\Support\Facades\Storage::disk("public")->path($p);
            $mime = @mime_content_type($abs) ?: null;
        } catch (\Throwable $e) {}

        if (!$mime) {
            $ext = strtolower(pathinfo($p, PATHINFO_EXTENSION));
            $mime = match ($ext) {
                "jpg", "jpeg" => "image/jpeg",
                "png" => "image/png",
                "webp" => "image/webp",
                default => "application/octet-stream",
            };
        }

        $imageParts[] = ["inlineData" => ["mimeType" => $mime, "data" => base64_encode($bin)]];
    }

    // 2) Prompt
    $promptText =
"Create ONE tall scrolling landing page mockup image FINAL OUTPUT IMAGE SIZE MUST BE EXACTLY 1080x1920 pixels (portrait, 9:16).
This is critical for mobile-first usage.
Direct-response marketing style., direct-response style.
CRITICAL: Use the ATTACHED images. Image #1 is the exact product packshot; keep brand/logo/colors/packaging consistent.
Use remaining images as supporting visuals (ingredients, lifestyle, proof, reviews style cards).
{$dialect}

Structure:
1) Hero (hook + promise + trust badges)
2) Before/After transformation
3) Authority + social proof + guarantee
4) Mechanism + ingredients grid + science visuals

Features to include if provided: {$features}.
High-converting, clean but energetic, product-centric, persuasive typography.";

    $parts = array_merge([["text" => $promptText]], $imageParts);

    // 3) Call Gemini image model
    $imageReq = [
        "contents" => [[ "parts" => $parts ]],
        "generationConfig" => [ "responseModalities" => ["IMAGE"] ]
    ];

    $ch = curl_init("https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent");
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_POST => true,
        CURLOPT_HTTPHEADER => ["Content-Type: application/json", "x-goog-api-key: {$apiKey}"],
        CURLOPT_POSTFIELDS => json_encode($imageReq),
        CURLOPT_TIMEOUT => 180,
    ]);
    $resp = curl_exec($ch);
    $http = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $err  = curl_error($ch);
    curl_close($ch);

    if ($resp === false) return response()->json(["ok"=>false,"message"=>"Image cURL error","error"=>$err], 500);

    $data = json_decode($resp, true);
    if ($http < 200 || $http >= 300) {
        return response()->json(["ok"=>false,"message"=>"Image model error","http"=>$http,"raw"=>$data], 500);
    }

    // 4) Extract returned inline image
    $outParts = $data["candidates"][0]["content"]["parts"] ?? [];
    $b64 = null;
    foreach ($outParts as $p) {
        if (isset($p["inlineData"]["data"])) { $b64 = $p["inlineData"]["data"]; break; }
    }
    if (!$b64) return response()->json(["ok"=>false,"message"=>"No inline image returned","raw"=>$data], 500);

    $outBin = base64_decode($b64);
    if ($outBin === false) return response()->json(["ok"=>false,"message"=>"base64 decode failed"], 500);

    $name = "outputs/lp_" . date("Ymd_His") . "_" . bin2hex(random_bytes(4)) . ".png";
    \Illuminate\Support\Facades\Storage::disk("public")->put($name, $outBin);

    return response()->json([
        "ok" => true,
        "output_url" => asset("storage/" . $name),
    ]);
});

Route::post("/upload", function (\Illuminate\Http\Request $request) {
    $files = [];

    if ($request->hasFile("images")) {
        $files = $request->file("images");
    } elseif ($request->hasFile("image")) {
        $files = [$request->file("image")];
    }

    if (!$files || count($files) === 0) {
        return response()->json(["ok"=>false,"message"=>"No images provided. Use image or images[]"], 422);
    }

    foreach ($files as $f) {
        if (!$f->isValid()) return response()->json(["ok"=>false,"message"=>"Invalid upload"], 422);
        $extOk = in_array(strtolower($f->getClientOriginalExtension()), ["jpg","jpeg","png","webp"]);
        if (!$extOk) return response()->json(["ok"=>false,"message"=>"Only jpg/jpeg/png/webp allowed"], 422);
        if ($f->getSize() > 8 * 1024 * 1024) return response()->json(["ok"=>false,"message"=>"Max 8MB per image"], 422);
    }

    $out = [];
    foreach ($files as $f) {
        $path = $f->store("uploads", "public");
        $out[] = ["path" => $path, "url" => asset("storage/" . $path)];
    }

    return response()->json(["ok" => true, "items" => $out]);
});
